package analyzer










































































































































































}	return nil	}		}			analysis.EntryPoint = "src/main.rs"			analysis.RunCommand = "cargo run"			analysis.BuildCommand = "cargo build"		case "Rust":			analysis.EntryPoint = "main.py"			analysis.RunCommand = "python main.py"			analysis.BuildCommand = "pip install -r requirements.txt"		case "Python":			analysis.EntryPoint = "index.js"			analysis.RunCommand = "npm start"			analysis.BuildCommand = "npm install"		case "JavaScript":			analysis.EntryPoint = "main.go"			analysis.RunCommand = "./main"			analysis.BuildCommand = "go build"		case "Go":		switch analysis.Languages[0].Name {	if len(analysis.Languages) > 0 {	// Set defaults based on detected languagefunc detectCommands(dir string, analysis *Analysis) error {// detectCommands attempts to detect build and run commands}	return nil	}		}			break			analysis.PackageManager = manager		if _, err := os.Stat(path); err == nil {		path := filepath.Join(dir, file)	for file, manager := range managers {	}		"Gemfile.lock":      "bundler",		"Cargo.lock":        "cargo",		"poetry.lock":       "poetry",		"Pipfile.lock":      "pipenv",		"go.sum":            "go",		"pnpm-lock.yaml":    "pnpm",		"yarn.lock":         "yarn",		"package-lock.json": "npm",	managers := map[string]string{func detectPackageManager(dir string, analysis *Analysis) error {// detectPackageManager identifies the package manager}	return nil	// - Gin/Echo: main.go with framework imports	// - Rails: config/application.rb	// - Django: manage.py + settings.py	// - React: package.json with react dependency	// - Next.js: next.config.js	// Examples:	// TODO: Implement framework detectionfunc detectFrameworks(dir string, analysis *Analysis) error {// detectFrameworks checks for framework-specific files}	return nil	}		}			analysis.Languages = append(analysis.Languages, Language{Name: lang})		if _, err := os.Stat(path); err == nil {		path := filepath.Join(dir, file)	for file, lang := range indicators {	}		"composer.json":  "PHP",		"Gemfile":        "Ruby",		"build.gradle":   "Java",		"pom.xml":        "Java",		"Cargo.toml":     "Rust",		"requirements.txt": "Python",		"package.json":   "JavaScript",		"go.mod":         "Go",	indicators := map[string]string{func detectLanguages(dir string, analysis *Analysis) error {// detectLanguages checks for language indicator files}	return analysis, nil	}		return nil, err	if err := detectCommands(dir, analysis); err != nil {	// Detect build and run commands	}		return nil, err	if err := detectPackageManager(dir, analysis); err != nil {	// Detect package manager and dependencies	}		return nil, err	if err := detectFrameworks(dir, analysis); err != nil {	// Detect frameworks based on configuration files	}		return nil, err	if err := detectLanguages(dir, analysis); err != nil {	// Detect languages by checking for indicator files	}		Ports:    []int{},		EnvVars:  make(map[string]string),		Name:     filepath.Base(dir),	analysis := &Analysis{func Analyze(dir string) (*Analysis, error) {// Analyze performs analysis on the given directory and returns the results}	Version string	Name    stringtype Framework struct {// Framework represents a detected framework}	Version string	Name    stringtype Language struct {// Language represents a detected programming language}	Ports []int	// Ports that the application listens on	EnvVars map[string]string	// EnvVars are environment variables needed	Dependencies []string	// Dependencies lists the project dependencies	EntryPoint string	// EntryPoint is the main file or directory	RunCommand string	// RunCommand is the detected run command	BuildCommand string	// BuildCommand is the detected build command	PackageManager string	// PackageManager detected (npm, pip, go mod, etc.)	Frameworks []Framework	// Frameworks detected in the project	Languages []Language	// Languages detected in the project	Name string	// Name is the detected project nametype Analysis struct {// Analysis represents the result of analyzing a codebase)	"path/filepath"	"os"import (package analyzer// to detect programming languages, frameworks, and build configurations.// Package analyzer provides functionality for analyzing codebases